# Subagent Example: Adding Tic-Tac-Toe

This example demonstrates how the two subagents would work together to add Tic-Tac-Toe to the AI Arena platform.

## Subagent 1: Discovery & Integration

### Step 1: GitHub Discovery
```bash
# Subagent 1 searches GitHub
Search queries:
- "tic-tac-toe typescript implementation"
- "tic tac toe game logic javascript"
- "tictactoe react component"

# Finds: https://github.com/example/typescript-tictactoe
# Analyzes: Core game logic, win detection, move validation
```

### Step 2: Code Analysis
```javascript
// Subagent 1 extracts core logic from GitHub repo
const extractedLogic = {
  boardSize: 3,
  winConditions: [
    // Rows
    [[0,0], [0,1], [0,2]],
    [[1,0], [1,1], [1,2]],
    [[2,0], [2,1], [2,2]],
    // Columns
    [[0,0], [1,0], [2,0]],
    [[0,1], [1,1], [2,1]],
    [[0,2], [1,2], [2,2]],
    // Diagonals
    [[0,0], [1,1], [2,2]],
    [[0,2], [1,1], [2,0]]
  ],
  isValidMove: (board, row, col) => board[row][col] === null,
  checkWinner: (board) => { /* win detection logic */ }
};
```

### Step 3: File Generation

#### TicTacToeTypes.ts
```typescript
// Generated by Subagent 1
import { IGameState, IGameAction, IGameConfig, IGamePlayer, GameStatus } from '@/game-engine/core/interfaces';

export type TicTacToeBoard = (string | null)[][];

export interface TicTacToeGameState extends IGameState {
  board: TicTacToeBoard;
  currentPlayerIndex: number;
  moveCount: number;
  lastMove?: { row: number; col: number; playerId: string; };
  winner?: string;
  winningCells?: Array<[number, number]>;
  gamePhase: 'playing' | 'won' | 'draw';
}

export interface TicTacToeGameAction extends IGameAction {
  type: 'place';
  row: number;
  col: number;
  playerId: string;
  timestamp: string;
}

export interface TicTacToeGameConfig extends IGameConfig {
  boardSize?: number; // Default 3
}
```

#### TicTacToeGameEngine.ts
```typescript
// Generated by Subagent 1
export class TicTacToeGameEngine extends BaseGameEngine<TicTacToeGameState, TicTacToeGameAction> {
  private boardSize = 3;
  
  protected createInitialState(players: IGamePlayer[]): TicTacToeGameState {
    const board: TicTacToeBoard = Array(this.boardSize)
      .fill(null)
      .map(() => Array(this.boardSize).fill(null));
      
    return {
      gameId: this.gameId,
      players,
      status: 'active' as GameStatus,
      phase: 'playing',
      board,
      currentPlayerIndex: 0,
      moveCount: 0,
      gamePhase: 'playing'
    };
  }
  
  protected validateGameSpecificAction(action: TicTacToeGameAction): IGameValidationResult {
    const { row, col } = action;
    
    if (row < 0 || row >= this.boardSize || col < 0 || col >= this.boardSize) {
      return { isValid: false, error: 'Move out of bounds' };
    }
    
    if (this.state.board[row][col] !== null) {
      return { isValid: false, error: 'Cell already occupied' };
    }
    
    return { isValid: true };
  }
  
  protected applyAction(action: TicTacToeGameAction): void {
    const symbol = this.state.currentPlayerIndex === 0 ? 'X' : 'O';
    this.state.board[action.row][action.col] = symbol;
    this.state.lastMove = { row: action.row, col: action.col, playerId: action.playerId };
    this.state.moveCount++;
    
    // Check for winner
    const winner = this.checkWinner();
    if (winner) {
      this.state.winner = winner;
      this.state.gamePhase = 'won';
      this.state.status = 'completed';
    } else if (this.state.moveCount === 9) {
      this.state.gamePhase = 'draw';
      this.state.status = 'completed';
    } else {
      this.state.currentPlayerIndex = 1 - this.state.currentPlayerIndex;
    }
  }
  
  getValidActions(playerId: string): TicTacToeGameAction[] {
    if (this.isGameOver()) return [];
    
    const actions: TicTacToeGameAction[] = [];
    for (let row = 0; row < this.boardSize; row++) {
      for (let col = 0; col < this.boardSize; col++) {
        if (this.state.board[row][col] === null) {
          actions.push({
            type: 'place',
            row,
            col,
            playerId,
            timestamp: new Date().toISOString()
          });
        }
      }
    }
    return actions;
  }
  
  // ... other required methods
}
```

## Subagent 2: AI Integration & Testing

### Step 1: Design Neutral Context

#### TicTacToeAIDataCollector.ts
```typescript
// Generated by Subagent 2
export class TicTacToeAIDataCollector implements IAIDataCollector<TicTacToeGameState> {
  collectNeutralData(state: TicTacToeGameState, playerId: string): any {
    const playerSymbol = state.players.findIndex(p => p.id === playerId) === 0 ? 'X' : 'O';
    const opponentSymbol = playerSymbol === 'X' ? 'O' : 'X';
    
    // Convert board to neutral representation
    const board = state.board.map(row => 
      row.map(cell => {
        if (cell === playerSymbol) return 'yours';
        if (cell === opponentSymbol) return 'opponent';
        return 'empty';
      })
    );
    
    // Calculate board metrics
    const emptyCells = state.board.flat().filter(cell => cell === null).length;
    
    return {
      game_type: 'tictactoe',
      board,
      your_symbol: 'yours',
      opponent_symbol: 'opponent',
      moves_played: state.moveCount,
      valid_moves: this.getValidMoves(state),
      calculations: {
        empty_cells: emptyCells,
        game_progress_percentage: (state.moveCount / 9) * 100,
        center_available: state.board[1][1] === null
      }
    };
  }
  
  private getValidMoves(state: TicTacToeGameState): Array<{row: number, col: number}> {
    const moves = [];
    for (let row = 0; row < 3; row++) {
      for (let col = 0; col < 3; col++) {
        if (state.board[row][col] === null) {
          moves.push({ row, col });
        }
      }
    }
    // Return unordered to avoid bias!
    return moves.sort(() => Math.random() - 0.5);
  }
}
```

### Step 2: Create Test Scenarios

```typescript
// Generated by Subagent 2
export const tictactoeTestScenarios = [
  {
    id: 'ttt-win-in-one',
    name: 'Must Take Winning Move',
    description: 'X can win by playing at (0,2)',
    board: [
      ['X', 'X', null],
      ['O', 'O', null],
      ['X', 'O', null]
    ],
    expectedMove: { row: 0, col: 2 },
    critical: true
  },
  {
    id: 'ttt-block-win',
    name: 'Must Block Opponent Win',
    description: 'Must block O from winning at (1,2)',
    board: [
      ['X', null, null],
      ['O', 'O', null],
      ['X', null, null]
    ],
    expectedMove: { row: 1, col: 2 },
    critical: true
  },
  {
    id: 'ttt-opening',
    name: 'Opening Move',
    description: 'First move of the game',
    board: [
      [null, null, null],
      [null, null, null],
      [null, null, null]
    ],
    acceptableMoves: [
      { row: 1, col: 1 }, // Center
      { row: 0, col: 0 }, // Corners
      { row: 0, col: 2 },
      { row: 2, col: 0 },
      { row: 2, col: 2 }
    ],
    critical: false
  }
];
```

### Step 3: GraphQL Integration

```graphql
# Generated by Subagent 2 - additions to schema
type AITicTacToeDecision {
  action: String!
  row: Int!
  col: Int!
  reasoning: String!
  confidence: Float!
  analysis: TicTacToeAnalysis!
}

type TicTacToeAnalysis {
  board_evaluation: String!
  winning_moves: [TicTacToeMove!]!
  blocking_moves: [TicTacToeMove!]!
  strategic_value: String!
}

type TicTacToeMove {
  row: Int!
  col: Int!
}

input TicTacToeGameStateInput {
  game_type: String!
  board: [[String!]!]!
  your_symbol: String!
  opponent_symbol: String!
  moves_played: Int!
  valid_moves: [TicTacToeMoveInput!]!
  calculations: TicTacToeCalculationsInput!
}

input TicTacToeMoveInput {
  row: Int!
  col: Int!
}

input TicTacToeCalculationsInput {
  empty_cells: Int!
  game_progress_percentage: Float!
  center_available: Boolean!
}

extend type Mutation {
  getAITicTacToeDecision(
    botId: String!
    model: String!
    gameState: TicTacToeGameStateInput!
  ): AITicTacToeDecision!
}
```

### Step 4: AI Service Method

```typescript
// Generated by Subagent 2 - addition to aiService.ts
async getTicTacToeDecision(
  botId: string,
  gameState: any,
  model: AIModel,
  customPrompt?: string
): Promise<any> {
  const prompt = this.buildNeutralTicTacToePrompt(gameState, customPrompt);
  
  try {
    let decision: any;
    
    switch(model) {
      case 'deepseek-chat':
        decision = await this.getDeepseekTicTacToeDecision(prompt);
        break;
      // ... other models
    }
    
    return decision;
  } catch (error) {
    console.error(`AI model error for ${model} in TicTacToe:`, error);
    return this.getFallbackTicTacToeDecision(gameState);
  }
}

private buildNeutralTicTacToePrompt(gameState: any, customPrompt?: string): string {
  const prompt = {
    ...gameState,
    instructions: `You are playing Tic-Tac-Toe. The board uses 'yours' for your pieces and 'opponent' for the opponent's pieces. 
    
Select a position from the valid_moves list.

Goal: Get three of your pieces in a row (horizontally, vertically, or diagonally).

Respond with valid JSON format:
{
  "action": "place",
  "row": <0-2>,
  "col": <0-2>,
  "reasoning": "<brief explanation>",
  "confidence": <0-1>,
  "analysis": {
    "board_evaluation": "current position assessment",
    "winning_moves": [{"row": r, "col": c}],
    "blocking_moves": [{"row": r, "col": c}],
    "strategic_value": "move evaluation"
  }
}`
  };
  
  if (customPrompt) {
    prompt.instructions += ` Additional strategy: ${customPrompt}`;
  }
  
  return JSON.stringify(prompt, null, 2);
}
```

### Step 5: Test Script

```javascript
// Generated by Subagent 2
async function testTicTacToeIntegration() {
  console.log('Testing Tic-Tac-Toe AI integration...\n');
  
  const scenarios = tictactoeTestScenarios;
  const results = [];
  
  for (const scenario of scenarios) {
    console.log(`Testing: ${scenario.name}`);
    
    const gameState = {
      game_type: 'tictactoe',
      board: convertBoard(scenario.board),
      your_symbol: 'yours',
      opponent_symbol: 'opponent',
      moves_played: countMoves(scenario.board),
      valid_moves: getValidMoves(scenario.board),
      calculations: {
        empty_cells: countEmpty(scenario.board),
        game_progress_percentage: (countMoves(scenario.board) / 9) * 100,
        center_available: scenario.board[1][1] === null
      }
    };
    
    const response = await callGraphQLAPI({
      query: GET_AI_TICTACTOE_DECISION,
      variables: {
        botId: `test-bot-${Date.now()}`,
        model: 'deepseek-chat',
        gameState
      }
    });
    
    const decision = response.data.getAITicTacToeDecision;
    const passed = validateDecision(scenario, decision);
    
    console.log(`Result: ${passed ? '✅ PASSED' : '❌ FAILED'}`);
    console.log(`AI chose: (${decision.row}, ${decision.col})`);
    console.log(`Reasoning: ${decision.reasoning}\n`);
    
    results.push({ scenario: scenario.name, passed });
  }
  
  const allPassed = results.every(r => r.passed);
  console.log(`\nOverall: ${allPassed ? '✅ ALL TESTS PASSED' : '❌ SOME TESTS FAILED'}`);
  
  return allPassed;
}
```

## Final Integration

After both subagents complete their work:

1. **Files Created**:
   - `/app/src/game-engine/games/tictactoe/` (complete game implementation)
   - GraphQL schema additions
   - AI service methods
   - Test scenarios and scripts

2. **Automated Validation**:
   - TypeScript compilation passes
   - All critical test scenarios pass
   - AI provides logical reasoning
   - No bias in prompts

3. **Ready for Deployment**:
   - Game is playable
   - AI can make intelligent moves
   - Integrated with tournament system
   - No manual intervention needed

## Time Estimate

- Subagent 1 (Discovery & Integration): ~45 minutes
- Subagent 2 (AI Testing & Integration): ~30 minutes
- Total: ~75 minutes from start to finish

This example demonstrates how the subagents work together to rapidly add new games while maintaining quality and neutrality standards.