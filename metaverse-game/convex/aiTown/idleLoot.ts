import { v } from 'convex/values';
import { internalMutation, internalAction, mutation, MutationCtx } from '../_generated/server';
import { Id } from '../_generated/dataModel';
import { playerId } from './ids';
import { internal } from '../_generated/api';
import { 
  getRandomItemForZone, 
  rollRarity, 
  calculateItemValue,
  GameItem 
} from '../../data/items';

// Helper function to check if a bot is valid (not a ghost bot)
function isValidBot(agent: any): boolean {
  // A valid bot has a non-empty aiArenaBotId (from AI Arena)
  // Ghost bots are those without aiArenaBotId or with null/undefined/empty values
  if (!agent.aiArenaBotId || agent.aiArenaBotId.trim() === '') {
    return false;
  }
  
  // All non-empty IDs are valid (including Prisma-generated IDs)
  return true;
}

// Zone drop multipliers for item rarity adjustment
const ZONE_DROP_MULTIPLIERS = {
  casino: { rarityBoost: 0.05, valueMultiplier: 1.5 },    // +5% rarity, +50% value
  darkAlley: { rarityBoost: 0.02, valueMultiplier: 1.0 }, // +2% rarity, normal value
  suburb: { rarityBoost: 0, valueMultiplier: 0.8 },       // Normal rarity, -20% value
  downtown: { rarityBoost: 0.01, valueMultiplier: 1.0 },  // +1% rarity, normal value
  underground: { rarityBoost: 0.03, valueMultiplier: 0.9 }, // +3% rarity, -10% value
};

// Convert our new item to loot format
function itemToLootFormat(item: GameItem | undefined, zone: string) {
  if (!item) {
    // Fallback to basic item if generation fails
    return {
      itemId: `loot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      name: 'Mystery Item',
      type: 'TOOL',
      rarity: 'COMMON',
      powerBonus: 1,
      defenseBonus: 1,
      value: 5,
    };
  }
  
  const zoneMultiplier = ZONE_DROP_MULTIPLIERS[zone as keyof typeof ZONE_DROP_MULTIPLIERS]?.valueMultiplier || 1.0;
  const baseValue = calculateItemValue(item);
  
  // Extract relevant bonuses based on item type
  let powerBonus = 0;
  let defenseBonus = 0;
  let speedBonus = 0;
  let agilityBonus = 0;
  let rangeBonus = 0;
  let healingPower = 0;
  let duration = 0;
  
  // Map item stats to our system
  if ('powerBonus' in item) powerBonus = item.powerBonus || 0;
  if ('defenseBonus' in item) defenseBonus = item.defenseBonus || 0;
  if ('speedBonus' in item) speedBonus = item.speedBonus || 0;
  if ('agilityBonus' in item) agilityBonus = item.agilityBonus || 0;
  if ('rangeBonus' in item) rangeBonus = item.rangeBonus || 0;
  if ('healingPower' in item) healingPower = item.healingPower || 0;
  if ('duration' in item) duration = item.duration || 0;
  
  return {
    itemId: item.id,
    name: item.name,
    type: item.type,
    rarity: item.rarity,
    powerBonus,
    defenseBonus,
    speedBonus,
    agilityBonus,
    rangeBonus,
    healingPower,
    duration,
    value: Math.floor(baseValue * zoneMultiplier),
    description: item.description,
    spritePosition: item.spritePosition,
  };
}

export const generateLootDrop = internalAction({
  args: {
    worldId: v.id('worlds'),
    playerId: playerId,
    zone: v.string(),
    position: v.object({
      x: v.number(),
      y: v.number(),
    }),
  },
  handler: async (ctx, args) => {
    // Get random item for the zone using our new system
    const item = getRandomItemForZone(args.zone);
    
    // Convert to loot format
    const loot = itemToLootFormat(item, args.zone);
    
    // Get player's inventory - use any to avoid deep type instantiation issue
    // @ts-ignore - Type instantiation depth issue with Convex types
    const inventory: any = await ctx.runQuery(internal.aiTown.inventory.getPlayerInventoryInternal, {
      worldId: args.worldId,
      playerId: args.playerId,
    });
    
    // Check if player has inventory space
    if (!inventory || !inventory.inventory || inventory.inventory.usedSlots >= inventory.inventory.maxSlots) {
      console.log(`Player ${args.playerId} inventory full, skipping loot drop`);
      return null;
    }
    
    // Create the item in the player's inventory
    await ctx.runMutation(internal.aiTown.idleLoot.addLootToInventory, {
      worldId: args.worldId,
      playerId: args.playerId,
      loot: loot,
    });
    
    // Log the loot drop - timestamp is auto-generated by Convex
    const itemName = loot.name;
    const quantity = 1;
    const currentZone = args.zone;
    const description = `Found ${itemName} worth ${loot.value} gold!`;
    
    // Enhanced emoji selection based on item type and rarity
    let emoji = '🪙'; // Default
    if (loot.rarity === 'GOD_TIER') {
      emoji = '🌟'; // God tier special
    } else if (loot.rarity === 'LEGENDARY') {
      emoji = '💎';
    } else if (loot.rarity === 'EPIC') {
      emoji = '🏆';
    } else if (loot.rarity === 'RARE') {
      emoji = '⭐';
    } else if (loot.rarity === 'UNCOMMON') {
      emoji = '💰';
    }
    
    // Override with type-specific emojis for certain items
    if (loot.type === 'SWORD') emoji = '⚔️';
    else if (loot.type === 'GUN') emoji = '🔫';
    else if (loot.type === 'POTION') emoji = '🧪';
    else if (loot.type === 'ARMOR' && loot.rarity === 'LEGENDARY') emoji = '🛡️';
    
    await ctx.runMutation(internal.aiTown.idleGains.trackIdleProgress, {
      worldId: args.worldId,
      playerId: args.playerId,
      progressType: 'item_collected',
      details: {
        item: itemName,
        amount: loot.value,
        zone: currentZone,
        rarity: loot.rarity,
      },
    });
    
    return loot;
  },
});

export const addLootToInventory = internalMutation({
  args: {
    worldId: v.id('worlds'),
    playerId: playerId,
    loot: v.object({
      itemId: v.string(),
      name: v.string(),
      type: v.string(),
      rarity: v.string(),
      powerBonus: v.number(),
      defenseBonus: v.number(),
      speedBonus: v.optional(v.number()),
      agilityBonus: v.optional(v.number()),
      rangeBonus: v.optional(v.number()),
      healingPower: v.optional(v.number()),
      duration: v.optional(v.number()),
      value: v.number(),
      description: v.optional(v.string()),
      spritePosition: v.optional(v.object({
        row: v.number(),
        col: v.number(),
      })),
    }),
  },
  handler: async (ctx, args) => {
    // Get or create inventory
    let inventory = await ctx.db
      .query('inventories')
      .withIndex('player', (q: any) => 
        q.eq('worldId', args.worldId).eq('playerId', args.playerId)
      )
      .first();
    
    if (!inventory) {
      // Create new inventory for the player
      const inventoryId = await ctx.db.insert('inventories', {
        worldId: args.worldId,
        playerId: args.playerId,
        maxSlots: 50,
        usedSlots: 0,
        lastUpdated: Date.now(),
        totalValue: 0,
      });
      
      inventory = await ctx.db.get(inventoryId);
    }
    
    // Create the item with all new fields
    await ctx.db.insert('items', {
      worldId: args.worldId,
      ownerId: args.playerId,
      itemId: args.loot.itemId,
      name: args.loot.name,
      type: args.loot.type as any,
      rarity: args.loot.rarity as any,
      powerBonus: args.loot.powerBonus,
      defenseBonus: args.loot.defenseBonus,
      // Add new stat fields
      speedBonus: args.loot.speedBonus || 0,
      agilityBonus: args.loot.agilityBonus || 0,
      rangeBonus: args.loot.rangeBonus || 0,
      healingPower: args.loot.healingPower || 0,
      duration: args.loot.duration || 0,
      // Handle consumables
      consumable: args.loot.type === 'POTION',
      quantity: args.loot.type === 'POTION' ? 1 : undefined,
      uses: args.loot.type === 'POTION' ? 1 : undefined,
      maxUses: args.loot.type === 'POTION' ? 1 : undefined,
      equipped: false,
      metadata: {
        description: args.loot.description || `A ${args.loot.rarity.toLowerCase()} ${args.loot.type.toLowerCase()} found while exploring`,
        tradeable: true,
        condition: 100,
        specialEffect: args.loot.type === 'POTION' ? 'Consumable on use' : undefined,
      },
      createdAt: Date.now(),
    });
    
    // Update inventory stats
    if (inventory) {
      await ctx.db.patch(inventory._id, {
        usedSlots: inventory.usedSlots + 1,
        totalValue: inventory.totalValue + args.loot.value,
        lastUpdated: Date.now(),
      });
    }
    
    // No auto-equip - all equipment changes must be manual by user
    
    return { success: true };
  },
});

// Grant movement XP operation
export const grantMovementXP = internalAction({
  args: {
    worldId: v.id('worlds'),
    playerId: playerId,
    aiArenaBotId: v.string(),
    baseXP: v.number(),
    bonusXP: v.number(),
  },
  handler: async (ctx, args) => {
    // Grant XP through the experience system (zone_activity grants 8 XP vs idle's 2 XP)
    await ctx.runMutation(internal.aiTown.experience.grantExperience, {
      worldId: args.worldId,
      playerId: args.playerId,
      aiArenaBotId: args.aiArenaBotId,
      activity: 'zone_activity', // Changed from 'idle' to grant more XP per movement
    });
  },
});

// Idle XP tick system - grants small amounts of XP periodically
export const tickIdleExperience = internalMutation({
  args: {
    worldId: v.id('worlds'),
  },
  handler: async (ctx, args) => {
    // Get the world
    const world = await ctx.db.get(args.worldId);
    if (!world) {
      console.log('World not found for idle XP tick');
      return;
    }

    // Get all agents in the world
    const agents = world.agents || [];
    let xpGranted = 0;
    let ghostBotsSkipped = 0;

    for (const agent of agents) {
      // Only grant XP to bots with aiArenaBotId and active agents
      if (!agent.playerId) {
        continue;
      }

      // Skip ghost bots (agents without valid aiArenaBotId)
      if (!isValidBot(agent)) {
        ghostBotsSkipped++;
        // Only log if there's a malformed aiArenaBotId
        if (agent.aiArenaBotId) {
          console.log(`Skipping invalid agent with malformed ID: ${agent.aiArenaBotId} (player: ${agent.playerId})`);
        }
        continue;
      }

      // Skip knocked out agents
      if (agent.knockedOutUntil && agent.knockedOutUntil > Date.now()) {
        continue;
      }

      // Get the player to check their current zone
      const player = world.players.find(p => p.id === agent.playerId);
      if (!player) {
        continue;
      }

      // Determine XP amount based on zone
      let baseXP = 1; // Reduced base idle XP (runs every 60s)
      const currentZone = player.currentZone || 'downtown';
      
      // Zone-based XP multipliers
      const zoneMultipliers = {
        casino: 1.5,      // Higher risk, higher reward
        darkAlley: 1.3,   // Dangerous zone
        underground: 1.2, // Combat zone
        downtown: 1.0,    // Normal zone
        suburb: 0.8,      // Safe zone
      };

      const multiplier = zoneMultipliers[currentZone as keyof typeof zoneMultipliers] || 1.0;
      const xpAmount = Math.ceil(baseXP * multiplier);

      // Grant the idle XP (aiArenaBotId is guaranteed to exist here because of isValidBot check)
      try {
        await ctx.scheduler.runAfter(0, internal.aiTown.experience.grantExperience, {
          worldId: args.worldId,
          playerId: agent.playerId,
          aiArenaBotId: agent.aiArenaBotId!,  // Safe to assert non-null after isValidBot check
          activity: 'idle', // New idle activity type
        });
        xpGranted++;
      } catch (error) {
        console.error(`Failed to grant idle XP to ${agent.playerId}:`, error);
      }
    }

    console.log(`Idle XP tick: Granted XP to ${xpGranted} bots, skipped ${ghostBotsSkipped} ghost bots`);
    return { botsUpdated: xpGranted, ghostBotsSkipped };
  },
});

// Schedule idle XP ticks periodically
export const scheduleIdleXPTicks = internalAction({
  args: {
    worldId: v.id('worlds'),
  },
  handler: async (ctx, args) => {
    // Run the idle XP tick
    await ctx.runMutation(internal.aiTown.idleLoot.tickIdleExperience, {
      worldId: args.worldId,
    });
    
    // Schedule the next tick in 10 seconds
    await ctx.scheduler.runAfter(10000, internal.aiTown.idleLoot.scheduleIdleXPTicks, {
      worldId: args.worldId,
    });
  },
});

// Manual trigger for testing idle XP
export const triggerIdleXP = mutation({
  args: {
    worldId: v.optional(v.id('worlds')),
  },
  handler: async (ctx, args) => {
    // Get default world if not specified
    let worldId = args.worldId;
    if (!worldId) {
      const worldStatus = await ctx.db
        .query('worldStatus')
        .filter((q) => q.eq(q.field('isDefault'), true))
        .first();
      
      if (!worldStatus) {
        throw new Error('No default world found');
      }
      worldId = worldStatus.worldId;
    }
    
    // Run the idle XP tick directly
    await ctx.runMutation(internal.aiTown.idleLoot.tickIdleExperience, {
      worldId,
    });
    
    return { success: true, worldId };
  },
});