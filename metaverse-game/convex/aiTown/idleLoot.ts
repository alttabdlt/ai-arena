import { v } from 'convex/values';
import { internalMutation, internalAction, mutation } from '../_generated/server';
import { playerId } from './ids';
import { internal } from '../_generated/api';

// Loot rarity tiers and their chances
const LOOT_RARITY_CHANCES = {
  COMMON: 0.60,     // 60% chance
  UNCOMMON: 0.25,   // 25% chance
  RARE: 0.10,       // 10% chance
  EPIC: 0.04,       // 4% chance
  LEGENDARY: 0.01,  // 1% chance
};

// Gold value ranges by rarity
const GOLD_VALUES = {
  COMMON: { min: 1, max: 5 },
  UNCOMMON: { min: 5, max: 20 },
  RARE: { min: 20, max: 100 },
  EPIC: { min: 100, max: 500 },
  LEGENDARY: { min: 500, max: 2000 },
};

// Item types by zone preference
const ZONE_LOOT_PREFERENCES = {
  casino: {
    types: ['ACCESSORY', 'TOOL'],
    goldMultiplier: 1.5,
    itemNames: ['Lucky Dice', 'Gold Coin', 'Casino Chip', 'Card Deck', 'Lucky Charm'],
  },
  darkAlley: {
    types: ['WEAPON', 'TOOL'],
    goldMultiplier: 1.0,
    itemNames: ['Rusty Knife', 'Brass Knuckles', 'Lockpick', 'Crowbar', 'Smoke Bomb'],
  },
  suburb: {
    types: ['ARMOR', 'ACCESSORY'],
    goldMultiplier: 0.8,
    itemNames: ['Garden Tool', 'Security Camera', 'Fence Panel', 'Lawn Ornament', 'Mailbox'],
  },
  downtown: {
    types: ['ACCESSORY', 'TOOL'],
    goldMultiplier: 1.0,
    itemNames: ['Smartphone', 'Briefcase', 'Watch', 'Sunglasses', 'Coffee Cup'],
  },
  underground: {
    types: ['WEAPON', 'ARMOR'],
    goldMultiplier: 0.7,
    itemNames: ['Training Gloves', 'Bandages', 'Energy Drink', 'Fight Tape', 'Mouthguard'],
  },
};

function rollLootRarity(): string {
  const roll = Math.random();
  let cumulative = 0;
  
  for (const [rarity, chance] of Object.entries(LOOT_RARITY_CHANCES)) {
    cumulative += chance;
    if (roll <= cumulative) {
      return rarity;
    }
  }
  
  return 'COMMON'; // Fallback
}

function generateLootItem(zone: string, rarity: string) {
  const zonePrefs = ZONE_LOOT_PREFERENCES[zone as keyof typeof ZONE_LOOT_PREFERENCES] 
    || ZONE_LOOT_PREFERENCES.downtown;
  
  // Pick a random item type from zone preferences
  const itemType = zonePrefs.types[Math.floor(Math.random() * zonePrefs.types.length)];
  
  // Pick a random item name from zone
  const itemName = zonePrefs.itemNames[Math.floor(Math.random() * zonePrefs.itemNames.length)];
  
  // Calculate item stats based on rarity
  const rarityMultipliers = {
    COMMON: 1,
    UNCOMMON: 2,
    RARE: 5,
    EPIC: 10,
    LEGENDARY: 25,
  };
  
  const multiplier = rarityMultipliers[rarity as keyof typeof rarityMultipliers] || 1;
  
  // Generate random base stats
  const basePower = Math.floor(Math.random() * 5) + 1;
  const baseDefense = Math.floor(Math.random() * 5) + 1;
  
  return {
    itemId: `loot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    name: `${rarity} ${itemName}`,
    type: itemType,
    rarity: rarity,
    powerBonus: basePower * multiplier,
    defenseBonus: baseDefense * multiplier,
    value: Math.floor(
      (GOLD_VALUES[rarity as keyof typeof GOLD_VALUES].min + 
       Math.random() * (GOLD_VALUES[rarity as keyof typeof GOLD_VALUES].max - 
                       GOLD_VALUES[rarity as keyof typeof GOLD_VALUES].min)) *
      zonePrefs.goldMultiplier
    ),
  };
}

export const generateLootDrop = internalAction({
  args: {
    worldId: v.id('worlds'),
    playerId: playerId,
    zone: v.string(),
    position: v.object({
      x: v.number(),
      y: v.number(),
    }),
  },
  handler: async (ctx, args) => {
    // Roll for loot rarity
    const rarity = rollLootRarity();
    
    // Generate the loot item
    const loot = generateLootItem(args.zone, rarity);
    
    // Get player's inventory - use any to avoid deep type instantiation issue
    // @ts-ignore - Type instantiation depth issue with Convex types
    const inventory: any = await ctx.runQuery(internal.aiTown.inventory.getPlayerInventoryInternal, {
      worldId: args.worldId,
      playerId: args.playerId,
    });
    
    // Check if player has inventory space
    if (!inventory || !inventory.inventory || inventory.inventory.usedSlots >= inventory.inventory.maxSlots) {
      console.log(`Player ${args.playerId} inventory full, skipping loot drop`);
      return null;
    }
    
    // Create the item in the player's inventory
    await ctx.runMutation(internal.aiTown.idleLoot.addLootToInventory, {
      worldId: args.worldId,
      playerId: args.playerId,
      loot: loot,
    });
    
    // Log the loot drop - timestamp is auto-generated by Convex
    const itemName = loot.name;
    const quantity = 1;
    const currentZone = args.zone;
    const description = `Found ${itemName} worth ${loot.value} gold!`;
    const emoji = rarity === 'LEGENDARY' ? 'ðŸ’Ž' : 
                  rarity === 'EPIC' ? 'ðŸ†' : 
                  rarity === 'RARE' ? 'â­' : 
                  rarity === 'UNCOMMON' ? 'ðŸ’°' : 'ðŸª™';
    
    await ctx.runMutation(internal.aiTown.idleGains.trackIdleProgress, {
      worldId: args.worldId,
      playerId: args.playerId,
      progressType: 'item_collected',
      details: {
        item: itemName,
        amount: loot.value,
        zone: currentZone,
        rarity: loot.rarity,
      },
    });
    
    return loot;
  },
});

export const addLootToInventory = internalMutation({
  args: {
    worldId: v.id('worlds'),
    playerId: playerId,
    loot: v.object({
      itemId: v.string(),
      name: v.string(),
      type: v.string(),
      rarity: v.string(),
      powerBonus: v.number(),
      defenseBonus: v.number(),
      value: v.number(),
    }),
  },
  handler: async (ctx, args) => {
    // Get or create inventory
    let inventory = await ctx.db
      .query('inventories')
      .withIndex('player', (q: any) => 
        q.eq('worldId', args.worldId).eq('playerId', args.playerId)
      )
      .first();
    
    if (!inventory) {
      // Create new inventory for the player
      const inventoryId = await ctx.db.insert('inventories', {
        worldId: args.worldId,
        playerId: args.playerId,
        maxSlots: 50,
        usedSlots: 0,
        lastUpdated: Date.now(),
        totalValue: 0,
      });
      
      inventory = await ctx.db.get(inventoryId);
    }
    
    // Create the item
    await ctx.db.insert('items', {
      worldId: args.worldId,
      ownerId: args.playerId,
      itemId: args.loot.itemId,
      name: args.loot.name,
      type: args.loot.type as any,
      rarity: args.loot.rarity as any,
      powerBonus: args.loot.powerBonus,
      defenseBonus: args.loot.defenseBonus,
      equipped: false,
      metadata: {
        description: `A ${args.loot.rarity.toLowerCase()} item found while exploring`,
        tradeable: true,
        condition: 100,
        // goldValue is stored as item value
      },
      createdAt: Date.now(),
    });
    
    // Update inventory stats
    if (inventory) {
      await ctx.db.patch(inventory._id, {
        usedSlots: inventory.usedSlots + 1,
        totalValue: inventory.totalValue + args.loot.value,
        lastUpdated: Date.now(),
      });
    }
    
    return { success: true };
  },
});

// Grant movement XP operation
export const grantMovementXP = internalAction({
  args: {
    worldId: v.id('worlds'),
    playerId: playerId,
    aiArenaBotId: v.string(),
    baseXP: v.number(),
    bonusXP: v.number(),
  },
  handler: async (ctx, args) => {
    // Grant XP through the experience system (only once, simplified)
    await ctx.runMutation(internal.aiTown.experience.grantExperience, {
      worldId: args.worldId,
      playerId: args.playerId,
      aiArenaBotId: args.aiArenaBotId,
      activity: 'idle', // Use idle activity which grants less XP
    });
  },
});

// Idle XP tick system - grants small amounts of XP periodically
export const tickIdleExperience = internalMutation({
  args: {
    worldId: v.id('worlds'),
  },
  handler: async (ctx, args) => {
    // Get the world
    const world = await ctx.db.get(args.worldId);
    if (!world) {
      console.log('World not found for idle XP tick');
      return;
    }

    // Get all agents in the world
    const agents = world.agents || [];
    let xpGranted = 0;

    for (const agent of agents) {
      // Only grant XP to bots with aiArenaBotId and active agents
      if (!agent.aiArenaBotId || !agent.playerId) {
        continue;
      }

      // Skip knocked out agents
      if (agent.knockedOutUntil && agent.knockedOutUntil > Date.now()) {
        continue;
      }

      // Get the player to check their current zone
      const player = world.players.find(p => p.id === agent.playerId);
      if (!player) {
        continue;
      }

      // Determine XP amount based on zone
      let baseXP = 1; // Reduced base idle XP (runs every 60s)
      const currentZone = player.currentZone || 'downtown';
      
      // Zone-based XP multipliers
      const zoneMultipliers = {
        casino: 1.5,      // Higher risk, higher reward
        darkAlley: 1.3,   // Dangerous zone
        underground: 1.2, // Combat zone
        downtown: 1.0,    // Normal zone
        suburb: 0.8,      // Safe zone
      };

      const multiplier = zoneMultipliers[currentZone as keyof typeof zoneMultipliers] || 1.0;
      const xpAmount = Math.ceil(baseXP * multiplier);

      // Grant the idle XP
      try {
        await ctx.scheduler.runAfter(0, internal.aiTown.experience.grantExperience, {
          worldId: args.worldId,
          playerId: agent.playerId,
          aiArenaBotId: agent.aiArenaBotId,
          activity: 'idle', // New idle activity type
        });
        xpGranted++;
      } catch (error) {
        console.error(`Failed to grant idle XP to ${agent.playerId}:`, error);
      }
    }

    console.log(`Idle XP tick: Granted XP to ${xpGranted} bots`);
    return { botsUpdated: xpGranted };
  },
});

// Schedule idle XP ticks periodically
export const scheduleIdleXPTicks = internalAction({
  args: {
    worldId: v.id('worlds'),
  },
  handler: async (ctx, args) => {
    // Run the idle XP tick
    await ctx.runMutation(internal.aiTown.idleLoot.tickIdleExperience, {
      worldId: args.worldId,
    });
    
    // Schedule the next tick in 10 seconds
    await ctx.scheduler.runAfter(10000, internal.aiTown.idleLoot.scheduleIdleXPTicks, {
      worldId: args.worldId,
    });
  },
});

// Manual trigger for testing idle XP
export const triggerIdleXP = mutation({
  args: {
    worldId: v.optional(v.id('worlds')),
  },
  handler: async (ctx, args) => {
    // Get default world if not specified
    let worldId = args.worldId;
    if (!worldId) {
      const worldStatus = await ctx.db
        .query('worldStatus')
        .filter((q) => q.eq(q.field('isDefault'), true))
        .first();
      
      if (!worldStatus) {
        throw new Error('No default world found');
      }
      worldId = worldStatus.worldId;
    }
    
    // Run the idle XP tick directly
    await ctx.runMutation(internal.aiTown.idleLoot.tickIdleExperience, {
      worldId,
    });
    
    return { success: true, worldId };
  },
});